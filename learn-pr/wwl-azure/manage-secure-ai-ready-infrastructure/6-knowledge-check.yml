### YamlMime:ModuleUnit
uid: learn.wwl.manage-secure-ai-ready-infrastructure.knowledge-check
title: "Module assessment"
metadata:
  title: "Knowledge check"
  description: "You've deployed secure AI infrastructure for Contoso using Azure RBAC, managed identities, and Cosmos DB with optimized configurations. Now test your understanding of when to apply these technologies and how to make the right architectural decisions for production workloads. The following questions present realistic scenarios that require you to evaluate security trade-offs, choose appropriate configurations, and identify best practices based on specific business requirements."
  ms.date: 02/02/2026
  author: wwlpublish
  ms.author: bradj
  ms.topic: unit
  module_assessment: false
durationInMinutes: 4
content: "Choose the best response for each of the following questions."
quiz:
  questions:
  - content: "Your AI agent hosted on Azure App Service needs to write conversation logs to Cosmos DB and retrieve API keys from Azure Key Vault for non-Microsoft service integration. The security team requires least-privilege access and prohibits storing credentials in application configuration. Which role assignments should you configure for the App Service's system-assigned managed identity?"
    choices:
    - content: "Assign Contributor role at the resource group level to grant access to all services including Cosmos DB and Key Vault with full management permissions"
      isCorrect: false
      explanation: "Assigning Cosmos DB Data Contributor and Key Vault Secrets User roles grants exactly the permissions required for the agent's job tasks: writing conversation data to Cosmos DB and reading secrets from Key Vault. This approach follows the principle of least privilege by avoiding unnecessary permissions like resource deletion or networking changes that Contributor provides. The first option (Contributor at resource group level) grants excessive permissions including the ability to delete databases and modify access policies, violating least-privilege principles and increasing breach risk by 80% according to Microsoft security benchmarks. The third option (Reader role with manual connection strings) fails to provide write access and reintroduces credential management overhead that managed identities are designed to eliminate. Correct configuration requires identifying the specific data operations the application performs (write to Cosmos DB, read from Key Vault) and assigning built-in roles that grant only those permissions at the narrowest possible scope (individual resource accounts rather than resource groups or subscriptions)."
    - content: "Assign Cosmos DB Data Contributor role on the Cosmos DB account and Key Vault Secrets User role on the Key Vault to grant specific data access without management permissions"
      isCorrect: true
      explanation: "Assigning Cosmos DB Data Contributor and Key Vault Secrets User roles grants exactly the permissions required for the agent's job tasks: writing conversation data to Cosmos DB and reading secrets from Key Vault. This approach follows the principle of least privilege by avoiding unnecessary permissions like resource deletion or networking changes that Contributor provides. The first option (Contributor at resource group level) grants excessive permissions including the ability to delete databases and modify access policies, violating least-privilege principles and increasing breach risk by 80% according to Microsoft security benchmarks. The third option (Reader role with manual connection strings) fails to provide write access and reintroduces credential management overhead that managed identities are designed to eliminate. Correct configuration requires identifying the specific data operations the application performs (write to Cosmos DB, read from Key Vault) and assigning built-in roles that grant only those permissions at the narrowest possible scope (individual resource accounts rather than resource groups or subscriptions)."
    - content: "Assign Reader role at the subscription level to allow the agent to view resource configurations, then manually provide connection strings for write operations"
      isCorrect: false
      explanation: "Assigning Cosmos DB Data Contributor and Key Vault Secrets User roles grants exactly the permissions required for the agent's job tasks: writing conversation data to Cosmos DB and reading secrets from Key Vault. This approach follows the principle of least privilege by avoiding unnecessary permissions like resource deletion or networking changes that Contributor provides. The first option (Contributor at resource group level) grants excessive permissions including the ability to delete databases and modify access policies, violating least-privilege principles and increasing breach risk by 80% according to Microsoft security benchmarks. The third option (Reader role with manual connection strings) fails to provide write access and reintroduces credential management overhead that managed identities are designed to eliminate. Correct configuration requires identifying the specific data operations the application performs (write to Cosmos DB, read from Key Vault) and assigning built-in roles that grant only those permissions at the narrowest possible scope (individual resource accounts rather than resource groups or subscriptions)."
  - content: "Contoso is deploying a microservices architecture with five different Azure Functions that all require identical access permissions to a shared Cosmos DB account for reading user profiles and writing analytics events. The operations team wants to minimize administrative overhead for identity and role management across development, staging, and production environments. Which managed identity approach should you implement?"
    choices:
    - content: "Enable system-assigned managed identities on all five Azure Functions and assign Cosmos DB Data Contributor role to each identity separately on the Cosmos DB account"
      isCorrect: false
      explanation: "Creating a single user-assigned managed identity and assigning it to all five Azure Functions reduces role assignment management from 15 assignments (5 functions × 3 environments) to just 3 assignments (1 identity × 3 environments), cutting administrative overhead by 80%. Because all functions require identical permissions, sharing an identity improves consistency—when permissions need updating, you modify a single role assignment rather than synchronizing changes across five separate identities. User-assigned identities persist independently of individual function lifecycles, allowing you to update or replace functions without recreating identity and role configurations. The first option (system-assigned identities with separate role assignments) works correctly but creates unnecessary management complexity: each function must receive its own role assignment, and adding a new function requires remembering to assign all necessary roles again. The third option (Microsoft Entra ID group containing system-assigned identities) isn't supported—Azure RBAC doesn't allow nesting managed identities in security groups for role assignment purposes; groups can contain users and service principals but not managed identities. The correct approach recognizes that when multiple resources need identical permissions, user-assigned identities reduce operational overhead while maintaining security through centralized permission management."
    - content: "Create a single user-assigned managed identity, assign it to all five Azure Functions, and grant Cosmos DB Data Contributor role once to this shared identity"
      isCorrect: true
      explanation: "Creating a single user-assigned managed identity and assigning it to all five Azure Functions reduces role assignment management from 15 assignments (5 functions × 3 environments) to just 3 assignments (1 identity × 3 environments), cutting administrative overhead by 80%. Because all functions require identical permissions, sharing an identity improves consistency—when permissions need updating, you modify a single role assignment rather than synchronizing changes across five separate identities. User-assigned identities persist independently of individual function lifecycles, allowing you to update or replace functions without recreating identity and role configurations. The first option (system-assigned identities with separate role assignments) works correctly but creates unnecessary management complexity: each function must receive its own role assignment, and adding a new function requires remembering to assign all necessary roles again. The third option (Microsoft Entra ID group containing system-assigned identities) isn't supported—Azure RBAC doesn't allow nesting managed identities in security groups for role assignment purposes; groups can contain users and service principals but not managed identities. The correct approach recognizes that when multiple resources need identical permissions, user-assigned identities reduce operational overhead while maintaining security through centralized permission management."
    - content: "Use system-assigned managed identities but create a custom Microsoft Entra ID group containing all five identities, then assign Cosmos DB Data Contributor role to the group for simplified management"
      isCorrect: false
      explanation: "Creating a single user-assigned managed identity and assigning it to all five Azure Functions reduces role assignment management from 15 assignments (5 functions × 3 environments) to just 3 assignments (1 identity × 3 environments), cutting administrative overhead by 80%. Because all functions require identical permissions, sharing an identity improves consistency—when permissions need updating, you modify a single role assignment rather than synchronizing changes across five separate identities. User-assigned identities persist independently of individual function lifecycles, allowing you to update or replace functions without recreating identity and role configurations. The first option (system-assigned identities with separate role assignments) works correctly but creates unnecessary management complexity: each function must receive its own role assignment, and adding a new function requires remembering to assign all necessary roles again. The third option (Microsoft Entra ID group containing system-assigned identities) isn't supported—Azure RBAC doesn't allow nesting managed identities in security groups for role assignment purposes; groups can contain users and service principals but not managed identities. The correct approach recognizes that when multiple resources need identical permissions, user-assigned identities reduce operational overhead while maintaining security through centralized permission management."
  - content: "Your AI agent stores conversation documents in Cosmos DB with 200,000 active users generating an average of 50 messages per user per month. Analytics queries frequently retrieve 'all conversations for a specific user from the last 30 days' to identify support patterns. The database currently experiences 30% throttling errors during peak hours and storage costs exceed budget by 40%. Which configuration changes would optimize both performance and cost?"
    choices:
    - content: "Change partition key from sessionId to userId and implement container-level TTL of 90 days to automatically expire old conversations; configure autoscale throughput from 400-10,000 RU/s"
      isCorrect: true
      explanation: "Changing the partition key to userId aligns data distribution with the query pattern ('all conversations for a specific user'), enabling single-partition queries that consume 70% fewer RUs compared to cross-partition scans and eliminate throttling errors. Container-level TTL automatically expires documents after 90 days without requiring scheduled deletion jobs, reducing storage consumption by 60% in mature deployments and satisfying data retention compliance. Autoscale throughput (400-10,000 RU/s) dynamically adjusts capacity based on real-time request volume, scaling down during overnight hours when conversation volume drops 80%, cutting throughput costs by 70% compared to static provisioning while maintaining performance during peak hours. The second option (permanently increased throughput) solves throttling but increases costs by 275% (from 4,000 to 15,000 RU/s) without addressing the root cause—inefficient queries requiring cross-partition scans. Manual deletion with stored procedures adds operational overhead, introduces potential service disruption during batch operations, and doesn't guarantee regulatory compliance compared to automatic TTL enforcement. The third option (composite index and Session consistency) improves query performance and reduces read latency but doesn't address the fundamental partition key mismatch that causes throttling; the autoscale range is also insufficient (max 5,000 RU/s) for the workload size. Correct optimization requires addressing the primary bottleneck (partition key alignment with query patterns) while implementing automated cost controls (TTL for storage, autoscale for throughput)."
    - content: "Keep current partition key but increase provisioned throughput from 4,000 RU/s to 15,000 RU/s permanently; implement stored procedures to batch-delete conversations older than 60 days weekly"
      isCorrect: false
      explanation: "Changing the partition key to userId aligns data distribution with the query pattern ('all conversations for a specific user'), enabling single-partition queries that consume 70% fewer RUs compared to cross-partition scans and eliminate throttling errors. Container-level TTL automatically expires documents after 90 days without requiring scheduled deletion jobs, reducing storage consumption by 60% in mature deployments and satisfying data retention compliance. Autoscale throughput (400-10,000 RU/s) dynamically adjusts capacity based on real-time request volume, scaling down during overnight hours when conversation volume drops 80%, cutting throughput costs by 70% compared to static provisioning while maintaining performance during peak hours. The second option (permanently increased throughput) solves throttling but increases costs by 275% (from 4,000 to 15,000 RU/s) without addressing the root cause—inefficient queries requiring cross-partition scans. Manual deletion with stored procedures adds operational overhead, introduces potential service disruption during batch operations, and doesn't guarantee regulatory compliance compared to automatic TTL enforcement. The third option (composite index and Session consistency) improves query performance and reduces read latency but doesn't address the fundamental partition key mismatch that causes throttling; the autoscale range is also insufficient (max 5,000 RU/s) for the workload size. Correct optimization requires addressing the primary bottleneck (partition key alignment with query patterns) while implementing automated cost controls (TTL for storage, autoscale for throughput)."
    - content: "Implement composite index on userId and timestamp fields; change consistency level from Strong to Session; configure autoscale throughput from 1,000-5,000 RU/s"
      isCorrect: false
      explanation: "Changing the partition key to userId aligns data distribution with the query pattern ('all conversations for a specific user'), enabling single-partition queries that consume 70% fewer RUs compared to cross-partition scans and eliminate throttling errors. Container-level TTL automatically expires documents after 90 days without requiring scheduled deletion jobs, reducing storage consumption by 60% in mature deployments and satisfying data retention compliance. Autoscale throughput (400-10,000 RU/s) dynamically adjusts capacity based on real-time request volume, scaling down during overnight hours when conversation volume drops 80%, cutting throughput costs by 70% compared to static provisioning while maintaining performance during peak hours. The second option (permanently increased throughput) solves throttling but increases costs by 275% (from 4,000 to 15,000 RU/s) without addressing the root cause—inefficient queries requiring cross-partition scans. Manual deletion with stored procedures adds operational overhead, introduces potential service disruption during batch operations, and doesn't guarantee regulatory compliance compared to automatic TTL enforcement. The third option (composite index and Session consistency) improves query performance and reduces read latency but doesn't address the fundamental partition key mismatch that causes throttling; the autoscale range is also insufficient (max 5,000 RU/s) for the workload size. Correct optimization requires addressing the primary bottleneck (partition key alignment with query patterns) while implementing automated cost controls (TTL for storage, autoscale for throughput)."
