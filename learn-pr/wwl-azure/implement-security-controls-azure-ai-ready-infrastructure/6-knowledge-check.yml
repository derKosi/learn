### YamlMime:ModuleUnit
uid: learn.wwl.implement-security-controls-azure-ai-ready-infrastructure.knowledge-check
title: "Module assessment"
metadata:
  title: "Knowledge check"
  description: "Test your understanding of Azure AI infrastructure security with this knowledge check. Learn about managed identities, governance scopes, and Azure Policy."
  ms.date: 02/09/2026
  author: wwlpublish
  ms.author: bradj
  ms.topic: unit
durationInMinutes: 6
content: "Choose the best response for each of the following questions."
quiz:
  questions:
  - content: "Your Azure Machine Learning workspace needs to access training data stored in an Azure Storage account. The workspace runs automated training pipelines that execute without human intervention. Your security team requires that no credentials be stored in code or configuration files. Which Microsoft Entra ID principal type should you configure for this scenario?"
    choices:
    - content: "Create a service principal with a client secret, store the secret in Azure Key Vault, and configure the ML workspace to retrieve the secret during pipeline execution."
      isCorrect: false
      explanation: "System-assigned managed identity is correct because it eliminates credential management entirely—Azure automatically handles authentication between the workspace and storage account without requiring secrets. The managed identity lifecycle is tied to the workspace, providing automatic cleanup. Service principals with secrets (option 1) introduce credential rotation requirements and risk accidental exposure, violating the no-stored-credentials requirement. User-assigned managed identity with Contributor at subscription level (option 3) violates least-privilege principles by granting excessive permissions across resources unrelated to this specific training pipeline scenario."
    - content: "Enable system-assigned managed identity on the ML workspace and grant it Storage Blob Data Reader role on the storage account."
      isCorrect: true
      explanation: "System-assigned managed identity is correct because it eliminates credential management entirely—Azure automatically handles authentication between the workspace and storage account without requiring secrets. The managed identity lifecycle is tied to the workspace, providing automatic cleanup. Service principals with secrets (option 1) introduce credential rotation requirements and risk accidental exposure, violating the no-stored-credentials requirement. User-assigned managed identity with Contributor at subscription level (option 3) violates least-privilege principles by granting excessive permissions across resources unrelated to this specific training pipeline scenario."
    - content: "Create a user-assigned managed identity, assign it to multiple ML workspaces across different projects, and grant it Contributor role at the subscription level for maximum flexibility."
      isCorrect: false
      explanation: "System-assigned managed identity is correct because it eliminates credential management entirely—Azure automatically handles authentication between the workspace and storage account without requiring secrets. The managed identity lifecycle is tied to the workspace, providing automatic cleanup. Service principals with secrets (option 1) introduce credential rotation requirements and risk accidental exposure, violating the no-stored-credentials requirement. User-assigned managed identity with Contributor at subscription level (option 3) violates least-privilege principles by granting excessive permissions across resources unrelated to this specific training pipeline scenario."
  - content: "Your organization runs AI workloads across three business units: Healthcare Analytics, Financial Services, and Retail Operations. Each unit requires different compliance controls—Healthcare must meet HIPAA requirements, Financial Services needs PCI-DSS compliance, and Retail has standard corporate policies. All units must follow organization-wide security baselines like mandatory encryption and approved regions. How should you structure Azure governance scopes to meet these requirements?"
    choices:
    - content: "Create a single subscription containing three resource groups (one per business unit), and use Azure Policy exemptions to apply different compliance controls to each resource group based on their specific requirements."
      isCorrect: false
      explanation: "Separate subscriptions under a shared management group are correct because subscriptions provide strong isolation boundaries needed for different compliance regimes (HIPAA, PCI-DSS), while the parent management group enforces common security baselines through policy inheritance. This structure eliminates policy duplication and simplifies audit reporting. Using resource groups with exemptions (option 1) doesn't provide sufficient isolation for compliance boundaries—HIPAA and PCI-DSS auditors typically require subscription-level separation. Creating separate management groups without a shared parent (option 3) forces you to duplicate all security baseline policies manually across three management groups, increasing configuration drift risk and administrative overhead by 3x."
    - content: "Create a management group with organization-wide policies, then create separate subscriptions for each business unit where unit-specific compliance policies apply, with all subscriptions inheriting the management group's security baseline."
      isCorrect: true
      explanation: "Separate subscriptions under a shared management group are correct because subscriptions provide strong isolation boundaries needed for different compliance regimes (HIPAA, PCI-DSS), while the parent management group enforces common security baselines through policy inheritance. This structure eliminates policy duplication and simplifies audit reporting. Using resource groups with exemptions (option 1) doesn't provide sufficient isolation for compliance boundaries—HIPAA and PCI-DSS auditors typically require subscription-level separation. Creating separate management groups without a shared parent (option 3) forces you to duplicate all security baseline policies manually across three management groups, increasing configuration drift risk and administrative overhead by 3x."
    - content: "Create three separate management groups (one per business unit) with no shared parent, configure identical security baseline policies in each management group manually, and create subscriptions under each management group for environment separation."
      isCorrect: false
      explanation: "Separate subscriptions under a shared management group are correct because subscriptions provide strong isolation boundaries needed for different compliance regimes (HIPAA, PCI-DSS), while the parent management group enforces common security baselines through policy inheritance. This structure eliminates policy duplication and simplifies audit reporting. Using resource groups with exemptions (option 1) doesn't provide sufficient isolation for compliance boundaries—HIPAA and PCI-DSS auditors typically require subscription-level separation. Creating separate management groups without a shared parent (option 3) forces you to duplicate all security baseline policies manually across three management groups, increasing configuration drift risk and administrative overhead by 3x."
  - content: "Your security team wants to ensure all new Azure Storage accounts used for AI workloads have diagnostic logging enabled automatically, without requiring manual configuration by data science teams. Existing storage accounts that lack diagnostic settings should be identified for remediation. Which Azure Policy effect combination accomplishes both objectives most efficiently?"
    choices:
    - content: "Assign a policy with Deny effect that blocks creation of storage accounts without diagnostic settings, then manually configure logging on existing noncompliant accounts identified through Azure portal review."
      isCorrect: false
      explanation: "DeployIfNotExists effect alone is correct because it handles both requirements in one policy: automatically deploying diagnostic settings to new storage accounts during creation (prevention) and enabling bulk remediation of existing noncompliant accounts through remediation tasks (fixing). This single-policy approach reduces administrative complexity. Deny effect (option 1) prevents future violations but requires manual remediation of existing resources, increasing operational work and leaving gaps until manual updates complete. Using separate Audit and DeployIfNotExists policies (option 2) is complex—DeployIfNotExists inherently includes audit functionality by identifying noncompliant resources before remediation, making a separate Audit policy redundant and doubling policy evaluation overhead."
    - content: "Assign a policy with Audit effect that generates compliance reports showing storage accounts lacking diagnostic settings, then create a second policy assignment with DeployIfNotExists effect that automatically adds diagnostic configurations to both new and existing storage accounts."
      isCorrect: false
      explanation: "DeployIfNotExists effect alone is correct because it handles both requirements in one policy: automatically deploying diagnostic settings to new storage accounts during creation (prevention) and enabling bulk remediation of existing noncompliant accounts through remediation tasks (fixing). This single-policy approach reduces administrative complexity. Deny effect (option 1) prevents future violations but requires manual remediation of existing resources, increasing operational work and leaving gaps until manual updates complete. Using separate Audit and DeployIfNotExists policies (option 2) is complex—DeployIfNotExists inherently includes audit functionality by identifying noncompliant resources before remediation, making a separate Audit policy redundant and doubling policy evaluation overhead."
    - content: "Assign a policy with DeployIfNotExists effect that automatically deploys diagnostic settings to new storage accounts and creates remediation tasks for existing accounts, providing both prevention and automated fixing in a single policy."
      isCorrect: true
      explanation: "DeployIfNotExists effect alone is correct because it handles both requirements in one policy: automatically deploying diagnostic settings to new storage accounts during creation (prevention) and enabling bulk remediation of existing noncompliant accounts through remediation tasks (fixing). This single-policy approach reduces administrative complexity. Deny effect (option 1) prevents future violations but requires manual remediation of existing resources, increasing operational work and leaving gaps until manual updates complete. Using separate Audit and DeployIfNotExists policies (option 2) is complex—DeployIfNotExists inherently includes audit functionality by identifying noncompliant resources before remediation, making a separate Audit policy redundant and doubling policy evaluation overhead."