AI applications demand fast, cost-effective data retrieval that scales with growing datasets and increasing query complexity. This module guides you through optimizing query performance for Azure Cosmos DB for NoSQL, helping you reduce latency, lower costs, and handle production workloads efficiently.

Imagine you're a developer who has built a semantic search platform that helps enterprise users find relevant documents across millions of stored files. Your application stores document metadata, extracted text, and vector embeddings generated by Azure OpenAI. Users search by keywords, filter by date ranges and document types, and expect semantically similar results ranked by relevance. Users expect response times under 100 milliseconds.

The application works well in development, but production testing reveals serious performance issues. Queries consume far more request units than budgeted, and latency spikes during peak usage. Investigation shows that the default indexing policy indexes every property, including large embedding arrays that inflate storage costs. Some queries perform full container scans because the required composite indexes don't exist. Users complain that recently uploaded documents don't appear in search results immediately. Your team needs to optimize the database configuration to support the application's diverse query patterns while staying within cost targets. You need to analyze which queries perform poorly, understand which index types support which query patterns, configure the right indexes for your access patterns, and select consistency levels that ensure users see their uploaded content. This module provides the techniques to transform your slow, expensive queries into efficient operations.

After completing this module, you'll be able to:

- Analyze query patterns and use metrics to identify performance bottlenecks and missing indexes
- Configure range and composite indexes to optimize filter and sort operations for AI retrieval patterns
- Select the appropriate vector index type based on dataset size, accuracy requirements, and performance goals
- Design indexing policies that balance read performance against write costs for your workload profile
- Choose consistency levels that meet application requirements while minimizing RU consumption
